"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shopify+app-bridge-react@4.1.6_react-dom@18.3.1_react@18.3.1";
exports.ids = ["vendor-chunks/@shopify+app-bridge-react@4.1.6_react-dom@18.3.1_react@18.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@shopify+app-bridge-react@4.1.6_react-dom@18.3.1_react@18.3.1/node_modules/@shopify/app-bridge-react/dist/index.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shopify+app-bridge-react@4.1.6_react-dom@18.3.1_react@18.3.1/node_modules/@shopify/app-bridge-react/dist/index.js ***!
  \***********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Modal: () => (/* binding */ pr),\n/* harmony export */   NavMenu: () => (/* binding */ br),\n/* harmony export */   SaveBar: () => (/* binding */ hr),\n/* harmony export */   TitleBar: () => (/* binding */ _r),\n/* harmony export */   useAppBridge: () => (/* binding */ Rr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.1.3_@babel+core@7.26.0_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/.pnpm/next@14.1.3_@babel+core@7.26.0_react-dom@18.3.1_react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\nvar ee = { exports: {} }, L = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Oe;\nfunction dr() {\n  if (Oe)\n    return L;\n  Oe = 1;\n  var R = react__WEBPACK_IMPORTED_MODULE_0__, v = Symbol.for(\"react.element\"), y = Symbol.for(\"react.fragment\"), c = Object.prototype.hasOwnProperty, C = R.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, x = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function h(a, d, b) {\n    var m, T = {}, w = null, E = null;\n    b !== void 0 && (w = \"\" + b), d.key !== void 0 && (w = \"\" + d.key), d.ref !== void 0 && (E = d.ref);\n    for (m in d)\n      c.call(d, m) && !x.hasOwnProperty(m) && (T[m] = d[m]);\n    if (a && a.defaultProps)\n      for (m in d = a.defaultProps, d)\n        T[m] === void 0 && (T[m] = d[m]);\n    return { $$typeof: v, type: a, key: w, ref: E, props: T, _owner: C.current };\n  }\n  return L.Fragment = y, L.jsx = h, L.jsxs = h, L;\n}\nvar $ = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Pe;\nfunction vr() {\n  return Pe || (Pe = 1,  true && function() {\n    var R = react__WEBPACK_IMPORTED_MODULE_0__, v = Symbol.for(\"react.element\"), y = Symbol.for(\"react.portal\"), c = Symbol.for(\"react.fragment\"), C = Symbol.for(\"react.strict_mode\"), x = Symbol.for(\"react.profiler\"), h = Symbol.for(\"react.provider\"), a = Symbol.for(\"react.context\"), d = Symbol.for(\"react.forward_ref\"), b = Symbol.for(\"react.suspense\"), m = Symbol.for(\"react.suspense_list\"), T = Symbol.for(\"react.memo\"), w = Symbol.for(\"react.lazy\"), E = Symbol.for(\"react.offscreen\"), k = Symbol.iterator, W = \"@@iterator\";\n    function Y(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = k && e[k] || e[W];\n      return typeof r == \"function\" ? r : null;\n    }\n    var O = R.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function p(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)\n          t[n - 1] = arguments[n];\n        ke(\"error\", e, t);\n      }\n    }\n    function ke(e, r, t) {\n      {\n        var n = O.ReactDebugCurrentFrame, u = n.getStackAddendum();\n        u !== \"\" && (r += \"%s\", t = t.concat([u]));\n        var s = t.map(function(o) {\n          return String(o);\n        });\n        s.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, s);\n      }\n    }\n    var De = !1, Ae = !1, Fe = !1, Ie = !1, Ne = !1, te;\n    te = Symbol.for(\"react.module.reference\");\n    function Le(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === c || e === x || Ne || e === C || e === b || e === m || Ie || e === E || De || Ae || Fe || typeof e == \"object\" && e !== null && (e.$$typeof === w || e.$$typeof === T || e.$$typeof === h || e.$$typeof === a || e.$$typeof === d || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === te || e.getModuleId !== void 0));\n    }\n    function $e(e, r, t) {\n      var n = e.displayName;\n      if (n)\n        return n;\n      var u = r.displayName || r.name || \"\";\n      return u !== \"\" ? t + \"(\" + u + \")\" : t;\n    }\n    function ne(e) {\n      return e.displayName || \"Context\";\n    }\n    function P(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && p(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case c:\n          return \"Fragment\";\n        case y:\n          return \"Portal\";\n        case x:\n          return \"Profiler\";\n        case C:\n          return \"StrictMode\";\n        case b:\n          return \"Suspense\";\n        case m:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case a:\n            var r = e;\n            return ne(r) + \".Consumer\";\n          case h:\n            var t = e;\n            return ne(t._context) + \".Provider\";\n          case d:\n            return $e(e, e.render, \"ForwardRef\");\n          case T:\n            var n = e.displayName || null;\n            return n !== null ? n : P(e.type) || \"Memo\";\n          case w: {\n            var u = e, s = u._payload, o = u._init;\n            try {\n              return P(o(s));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var D = Object.assign, I = 0, ae, ie, oe, ue, se, le, fe;\n    function ce() {\n    }\n    ce.__reactDisabledLog = !0;\n    function We() {\n      {\n        if (I === 0) {\n          ae = console.log, ie = console.info, oe = console.warn, ue = console.error, se = console.group, le = console.groupCollapsed, fe = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: ce,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        I++;\n      }\n    }\n    function Ye() {\n      {\n        if (I--, I === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: D({}, e, {\n              value: ae\n            }),\n            info: D({}, e, {\n              value: ie\n            }),\n            warn: D({}, e, {\n              value: oe\n            }),\n            error: D({}, e, {\n              value: ue\n            }),\n            group: D({}, e, {\n              value: se\n            }),\n            groupCollapsed: D({}, e, {\n              value: le\n            }),\n            groupEnd: D({}, e, {\n              value: fe\n            })\n          });\n        }\n        I < 0 && p(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var J = O.ReactCurrentDispatcher, G;\n    function M(e, r, t) {\n      {\n        if (G === void 0)\n          try {\n            throw Error();\n          } catch (u) {\n            var n = u.stack.trim().match(/\\n( *(at )?)/);\n            G = n && n[1] || \"\";\n          }\n        return `\n` + G + e;\n      }\n    }\n    var z = !1, B;\n    {\n      var Me = typeof WeakMap == \"function\" ? WeakMap : Map;\n      B = new Me();\n    }\n    function de(e, r) {\n      if (!e || z)\n        return \"\";\n      {\n        var t = B.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var n;\n      z = !0;\n      var u = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var s;\n      s = J.current, J.current = null, We();\n      try {\n        if (r) {\n          var o = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(o.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(o, []);\n            } catch (S) {\n              n = S;\n            }\n            Reflect.construct(e, [], o);\n          } else {\n            try {\n              o.call();\n            } catch (S) {\n              n = S;\n            }\n            e.call(o.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (S) {\n            n = S;\n          }\n          e();\n        }\n      } catch (S) {\n        if (S && n && typeof S.stack == \"string\") {\n          for (var i = S.stack.split(`\n`), g = n.stack.split(`\n`), l = i.length - 1, f = g.length - 1; l >= 1 && f >= 0 && i[l] !== g[f]; )\n            f--;\n          for (; l >= 1 && f >= 0; l--, f--)\n            if (i[l] !== g[f]) {\n              if (l !== 1 || f !== 1)\n                do\n                  if (l--, f--, f < 0 || i[l] !== g[f]) {\n                    var _ = `\n` + i[l].replace(\" at new \", \" at \");\n                    return e.displayName && _.includes(\"<anonymous>\") && (_ = _.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && B.set(e, _), _;\n                  }\n                while (l >= 1 && f >= 0);\n              break;\n            }\n        }\n      } finally {\n        z = !1, J.current = s, Ye(), Error.prepareStackTrace = u;\n      }\n      var F = e ? e.displayName || e.name : \"\", we = F ? M(F) : \"\";\n      return typeof e == \"function\" && B.set(e, we), we;\n    }\n    function Be(e, r, t) {\n      return de(e, !1);\n    }\n    function Ve(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function V(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return de(e, Ve(e));\n      if (typeof e == \"string\")\n        return M(e);\n      switch (e) {\n        case b:\n          return M(\"Suspense\");\n        case m:\n          return M(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case d:\n            return Be(e.render);\n          case T:\n            return V(e.type, r, t);\n          case w: {\n            var n = e, u = n._payload, s = n._init;\n            try {\n              return V(s(u), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var U = Object.prototype.hasOwnProperty, ve = {}, pe = O.ReactDebugCurrentFrame;\n    function q(e) {\n      if (e) {\n        var r = e._owner, t = V(e.type, e._source, r ? r.type : null);\n        pe.setExtraStackFrame(t);\n      } else\n        pe.setExtraStackFrame(null);\n    }\n    function Ue(e, r, t, n, u) {\n      {\n        var s = Function.call.bind(U);\n        for (var o in e)\n          if (s(e, o)) {\n            var i = void 0;\n            try {\n              if (typeof e[o] != \"function\") {\n                var g = Error((n || \"React class\") + \": \" + t + \" type `\" + o + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[o] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw g.name = \"Invariant Violation\", g;\n              }\n              i = e[o](r, o, n, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (l) {\n              i = l;\n            }\n            i && !(i instanceof Error) && (q(u), p(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", n || \"React class\", t, o, typeof i), q(null)), i instanceof Error && !(i.message in ve) && (ve[i.message] = !0, q(u), p(\"Failed %s type: %s\", t, i.message), q(null));\n          }\n      }\n    }\n    var qe = Array.isArray;\n    function K(e) {\n      return qe(e);\n    }\n    function Je(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function Ge(e) {\n      try {\n        return ye(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function ye(e) {\n      return \"\" + e;\n    }\n    function he(e) {\n      if (Ge(e))\n        return p(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Je(e)), ye(e);\n    }\n    var N = O.ReactCurrentOwner, ze = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, me, ge, X;\n    X = {};\n    function Ke(e) {\n      if (U.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function Xe(e) {\n      if (U.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function Ze(e, r) {\n      if (typeof e.ref == \"string\" && N.current && r && N.current.stateNode !== r) {\n        var t = P(N.current.type);\n        X[t] || (p('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', P(N.current.type), e.ref), X[t] = !0);\n      }\n    }\n    function Qe(e, r) {\n      {\n        var t = function() {\n          me || (me = !0, p(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function He(e, r) {\n      {\n        var t = function() {\n          ge || (ge = !0, p(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var er = function(e, r, t, n, u, s, o) {\n      var i = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: v,\n        // Built-in properties that belong on the element\n        type: e,\n        key: r,\n        ref: t,\n        props: o,\n        // Record the component responsible for creating this element.\n        _owner: s\n      };\n      return i._store = {}, Object.defineProperty(i._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(i, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: n\n      }), Object.defineProperty(i, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: u\n      }), Object.freeze && (Object.freeze(i.props), Object.freeze(i)), i;\n    };\n    function rr(e, r, t, n, u) {\n      {\n        var s, o = {}, i = null, g = null;\n        t !== void 0 && (he(t), i = \"\" + t), Xe(r) && (he(r.key), i = \"\" + r.key), Ke(r) && (g = r.ref, Ze(r, u));\n        for (s in r)\n          U.call(r, s) && !ze.hasOwnProperty(s) && (o[s] = r[s]);\n        if (e && e.defaultProps) {\n          var l = e.defaultProps;\n          for (s in l)\n            o[s] === void 0 && (o[s] = l[s]);\n        }\n        if (i || g) {\n          var f = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          i && Qe(o, f), g && He(o, f);\n        }\n        return er(e, i, g, u, n, N.current, o);\n      }\n    }\n    var Z = O.ReactCurrentOwner, Ee = O.ReactDebugCurrentFrame;\n    function A(e) {\n      if (e) {\n        var r = e._owner, t = V(e.type, e._source, r ? r.type : null);\n        Ee.setExtraStackFrame(t);\n      } else\n        Ee.setExtraStackFrame(null);\n    }\n    var Q;\n    Q = !1;\n    function H(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === v;\n    }\n    function be() {\n      {\n        if (Z.current) {\n          var e = P(Z.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function tr(e) {\n      {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), t = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + t + \".\";\n        }\n        return \"\";\n      }\n    }\n    var _e = {};\n    function nr(e) {\n      {\n        var r = be();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function Re(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = nr(r);\n        if (_e[t])\n          return;\n        _e[t] = !0;\n        var n = \"\";\n        e && e._owner && e._owner !== Z.current && (n = \" It was passed a child from \" + P(e._owner.type) + \".\"), A(e), p('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n), A(null);\n      }\n    }\n    function Te(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (K(e))\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            H(n) && Re(n, r);\n          }\n        else if (H(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var u = Y(e);\n          if (typeof u == \"function\" && u !== e.entries)\n            for (var s = u.call(e), o; !(o = s.next()).done; )\n              H(o.value) && Re(o.value, r);\n        }\n      }\n    }\n    function ar(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === d || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        r.$$typeof === T))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var n = P(r);\n          Ue(t, e.props, \"prop\", n, e);\n        } else if (r.PropTypes !== void 0 && !Q) {\n          Q = !0;\n          var u = P(r);\n          p(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", u || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && p(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function ir(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var n = r[t];\n          if (n !== \"children\" && n !== \"key\") {\n            A(e), p(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", n), A(null);\n            break;\n          }\n        }\n        e.ref !== null && (A(e), p(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), A(null));\n      }\n    }\n    function Ce(e, r, t, n, u, s) {\n      {\n        var o = Le(e);\n        if (!o) {\n          var i = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (i += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var g = tr(u);\n          g ? i += g : i += be();\n          var l;\n          e === null ? l = \"null\" : K(e) ? l = \"array\" : e !== void 0 && e.$$typeof === v ? (l = \"<\" + (P(e.type) || \"Unknown\") + \" />\", i = \" Did you accidentally export a JSX literal instead of a component?\") : l = typeof e, p(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", l, i);\n        }\n        var f = rr(e, r, t, u, s);\n        if (f == null)\n          return f;\n        if (o) {\n          var _ = r.children;\n          if (_ !== void 0)\n            if (n)\n              if (K(_)) {\n                for (var F = 0; F < _.length; F++)\n                  Te(_[F], e);\n                Object.freeze && Object.freeze(_);\n              } else\n                p(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Te(_, e);\n        }\n        return e === c ? ir(f) : ar(f), f;\n      }\n    }\n    function or(e, r, t) {\n      return Ce(e, r, t, !0);\n    }\n    function ur(e, r, t) {\n      return Ce(e, r, t, !1);\n    }\n    var sr = ur, lr = or;\n    $.Fragment = c, $.jsx = sr, $.jsxs = lr;\n  }()), $;\n}\n false ? 0 : ee.exports = vr();\nvar re = ee.exports;\nconst pr = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function({ open: v, onShow: y, onHide: c, children: C, ...x }, h) {\n  const [a, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), { titleBar: b, saveBar: m, modalContent: T } = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(C).reduce(\n    (E, k) => {\n      const W = yr(k), Y = W === \"ui-title-bar\", O = W === \"ui-save-bar\";\n      return !Y && !O && E.modalContent.push(k), {\n        ...E,\n        titleBar: Y ? k : E.titleBar,\n        saveBar: O ? k : E.saveBar\n      };\n    },\n    { modalContent: [] }\n  ), w = a && a.content ? react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(T, a.content) : null;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    a && (v ? a.show() : a.hide());\n  }, [a, v]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!(!a || !y))\n      return a.addEventListener(\"show\", y), () => {\n        a.removeEventListener(\"show\", y);\n      };\n  }, [a, y]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!(!a || !c))\n      return a.addEventListener(\"hide\", c), () => {\n        a.removeEventListener(\"hide\", c);\n      };\n  }, [a, c]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (a)\n      return () => {\n        a.hide();\n      };\n  }, [a]), /* @__PURE__ */ re.jsxs(\n    \"ui-modal\",\n    {\n      ...x,\n      ref: (E) => {\n        d(E), h && (typeof h == \"function\" ? h(E) : h.current = E);\n      },\n      children: [\n        b,\n        m,\n        /* @__PURE__ */ re.jsx(\"div\", { children: w })\n      ]\n    }\n  );\n});\npr.displayName = \"ui-modal\";\nfunction yr(R) {\n  if (!R)\n    return;\n  const v = typeof R == \"object\" && \"type\" in R ? R.type : void 0, y = typeof v == \"string\" ? v : void 0, c = typeof v == \"object\" ? v.displayName : void 0;\n  return y || (typeof c == \"string\" ? c : void 0);\n}\nconst br = \"ui-nav-menu\", _r = \"ui-title-bar\", hr = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function({ open: v, onShow: y, onHide: c, children: C, ...x }, h) {\n  const [a, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    a && (v ? a.show() : a.hide());\n  }, [a, v]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!(!a || !y))\n      return a.addEventListener(\"show\", y), () => {\n        a.removeEventListener(\"show\", y);\n      };\n  }, [a, y]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!(!a || !c))\n      return a.addEventListener(\"hide\", c), () => {\n        a.removeEventListener(\"hide\", c);\n      };\n  }, [a, c]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (a)\n      return () => {\n        a.hide();\n      };\n  }, [a]), /* @__PURE__ */ re.jsx(\n    \"ui-save-bar\",\n    {\n      ...x,\n      ref: (b) => {\n        d(b), h && (typeof h == \"function\" ? h(b) : h.current = b);\n      },\n      children: C\n    }\n  );\n});\nhr.displayName = \"ui-save-bar\";\nconst mr = new Proxy(\n  {},\n  {\n    get(R, v) {\n      throw Error(\n        `shopify.${String(\n          v\n        )} can't be used in a server environment. You likely need to move this code into an Effect.`\n      );\n    }\n  }\n);\nfunction Rr() {\n  if (typeof window > \"u\")\n    return mr;\n  if (!window.shopify)\n    throw Error(\n      \"The shopify global is not defined. This likely means the App Bridge script tag was not added correctly to this page\"\n    );\n  return window.shopify;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNob3BpZnkrYXBwLWJyaWRnZS1yZWFjdEA0LjEuNl9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvQHNob3BpZnkvYXBwLWJyaWRnZS1yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkY7QUFDbEU7QUFDM0IsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFFLDRMQUE0TDtBQUN4TTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdELFlBQVksa0NBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQ0FBbUM7QUFDM0U7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQXFDLEdBQUcsQ0FBaUI7QUFDekQ7QUFDQSxXQUFXLGlEQUFFLFlBQVksa0RBQWtEO0FBQzNFLGlCQUFpQiwrQ0FBRSxNQUFNLDJDQUEyQyxFQUFFLDJDQUFFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTiwwQkFBMEIsbURBQWU7QUFDekMsU0FBUyxnREFBQztBQUNWO0FBQ0EsR0FBRyxXQUFXLGdEQUFDO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFdBQVcsZ0RBQUM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsV0FBVyxnREFBQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlEQUFFLFlBQVksa0RBQWtEO0FBQ3BILGlCQUFpQiwrQ0FBRTtBQUNuQixTQUFTLGdEQUFDO0FBQ1Y7QUFDQSxHQUFHLFdBQVcsZ0RBQUM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsV0FBVyxnREFBQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxXQUFXLGdEQUFDO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWFwcC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hvcGlmeSthcHAtYnJpZGdlLXJlYWN0QDQuMS42X3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9hcHAtYnJpZGdlLXJlYWN0L2Rpc3QvaW5kZXguanM/ZjFkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU2UsIHsgZm9yd2FyZFJlZiBhcyB4ZSwgdXNlU3RhdGUgYXMgamUsIENoaWxkcmVuIGFzIGZyLCB1c2VFZmZlY3QgYXMgaiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IGNyIGZyb20gXCJyZWFjdC1kb21cIjtcbnZhciBlZSA9IHsgZXhwb3J0czoge30gfSwgTCA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIE9lO1xuZnVuY3Rpb24gZHIoKSB7XG4gIGlmIChPZSlcbiAgICByZXR1cm4gTDtcbiAgT2UgPSAxO1xuICB2YXIgUiA9IFNlLCB2ID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIHkgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIGMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBDID0gUi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lciwgeCA9IHsga2V5OiAhMCwgcmVmOiAhMCwgX19zZWxmOiAhMCwgX19zb3VyY2U6ICEwIH07XG4gIGZ1bmN0aW9uIGgoYSwgZCwgYikge1xuICAgIHZhciBtLCBUID0ge30sIHcgPSBudWxsLCBFID0gbnVsbDtcbiAgICBiICE9PSB2b2lkIDAgJiYgKHcgPSBcIlwiICsgYiksIGQua2V5ICE9PSB2b2lkIDAgJiYgKHcgPSBcIlwiICsgZC5rZXkpLCBkLnJlZiAhPT0gdm9pZCAwICYmIChFID0gZC5yZWYpO1xuICAgIGZvciAobSBpbiBkKVxuICAgICAgYy5jYWxsKGQsIG0pICYmICF4Lmhhc093blByb3BlcnR5KG0pICYmIChUW21dID0gZFttXSk7XG4gICAgaWYgKGEgJiYgYS5kZWZhdWx0UHJvcHMpXG4gICAgICBmb3IgKG0gaW4gZCA9IGEuZGVmYXVsdFByb3BzLCBkKVxuICAgICAgICBUW21dID09PSB2b2lkIDAgJiYgKFRbbV0gPSBkW21dKTtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogdiwgdHlwZTogYSwga2V5OiB3LCByZWY6IEUsIHByb3BzOiBULCBfb3duZXI6IEMuY3VycmVudCB9O1xuICB9XG4gIHJldHVybiBMLkZyYWdtZW50ID0geSwgTC5qc3ggPSBoLCBMLmpzeHMgPSBoLCBMO1xufVxudmFyICQgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBQZTtcbmZ1bmN0aW9uIHZyKCkge1xuICByZXR1cm4gUGUgfHwgKFBlID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHZhciBSID0gU2UsIHYgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgeSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksIGMgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIEMgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksIHggPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksIGggPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksIGEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgZCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgYiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLCBUID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIHcgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksIGsgPSBTeW1ib2wuaXRlcmF0b3IsIFcgPSBcIkBAaXRlcmF0b3JcIjtcbiAgICBmdW5jdGlvbiBZKGUpIHtcbiAgICAgIGlmIChlID09PSBudWxsIHx8IHR5cGVvZiBlICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHIgPSBrICYmIGVba10gfHwgZVtXXTtcbiAgICAgIHJldHVybiB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIE8gPSBSLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgIGZ1bmN0aW9uIHAoZSkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciByID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShyID4gMSA/IHIgLSAxIDogMCksIG4gPSAxOyBuIDwgcjsgbisrKVxuICAgICAgICAgIHRbbiAtIDFdID0gYXJndW1lbnRzW25dO1xuICAgICAgICBrZShcImVycm9yXCIsIGUsIHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBrZShlLCByLCB0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBuID0gTy5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCB1ID0gbi5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIHUgIT09IFwiXCIgJiYgKHIgKz0gXCIlc1wiLCB0ID0gdC5jb25jYXQoW3VdKSk7XG4gICAgICAgIHZhciBzID0gdC5tYXAoZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcobyk7XG4gICAgICAgIH0pO1xuICAgICAgICBzLnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIHIpLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2VdLCBjb25zb2xlLCBzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIERlID0gITEsIEFlID0gITEsIEZlID0gITEsIEllID0gITEsIE5lID0gITEsIHRlO1xuICAgIHRlID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgZnVuY3Rpb24gTGUoZSkge1xuICAgICAgcmV0dXJuICEhKHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiIHx8IGUgPT09IGMgfHwgZSA9PT0geCB8fCBOZSB8fCBlID09PSBDIHx8IGUgPT09IGIgfHwgZSA9PT0gbSB8fCBJZSB8fCBlID09PSBFIHx8IERlIHx8IEFlIHx8IEZlIHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiAoZS4kJHR5cGVvZiA9PT0gdyB8fCBlLiQkdHlwZW9mID09PSBUIHx8IGUuJCR0eXBlb2YgPT09IGggfHwgZS4kJHR5cGVvZiA9PT0gYSB8fCBlLiQkdHlwZW9mID09PSBkIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgICAgLy8gd2l0aC5cbiAgICAgIGUuJCR0eXBlb2YgPT09IHRlIHx8IGUuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiAkZShlLCByLCB0KSB7XG4gICAgICB2YXIgbiA9IGUuZGlzcGxheU5hbWU7XG4gICAgICBpZiAobilcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB2YXIgdSA9IHIuZGlzcGxheU5hbWUgfHwgci5uYW1lIHx8IFwiXCI7XG4gICAgICByZXR1cm4gdSAhPT0gXCJcIiA/IHQgKyBcIihcIiArIHUgKyBcIilcIiA6IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5lKGUpIHtcbiAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQKGUpIHtcbiAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBlLnRhZyA9PSBcIm51bWJlclwiICYmIHAoXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKSwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSB5OlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIHg6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBDOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBiOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgbTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIGE6XG4gICAgICAgICAgICB2YXIgciA9IGU7XG4gICAgICAgICAgICByZXR1cm4gbmUocikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgaDpcbiAgICAgICAgICAgIHZhciB0ID0gZTtcbiAgICAgICAgICAgIHJldHVybiBuZSh0Ll9jb250ZXh0KSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBkOlxuICAgICAgICAgICAgcmV0dXJuICRlKGUsIGUucmVuZGVyLCBcIkZvcndhcmRSZWZcIik7XG4gICAgICAgICAgY2FzZSBUOlxuICAgICAgICAgICAgdmFyIG4gPSBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbiAhPT0gbnVsbCA/IG4gOiBQKGUudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgY2FzZSB3OiB7XG4gICAgICAgICAgICB2YXIgdSA9IGUsIHMgPSB1Ll9wYXlsb2FkLCBvID0gdS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBQKG8ocykpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBEID0gT2JqZWN0LmFzc2lnbiwgSSA9IDAsIGFlLCBpZSwgb2UsIHVlLCBzZSwgbGUsIGZlO1xuICAgIGZ1bmN0aW9uIGNlKCkge1xuICAgIH1cbiAgICBjZS5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICBmdW5jdGlvbiBXZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEkgPT09IDApIHtcbiAgICAgICAgICBhZSA9IGNvbnNvbGUubG9nLCBpZSA9IGNvbnNvbGUuaW5mbywgb2UgPSBjb25zb2xlLndhcm4sIHVlID0gY29uc29sZS5lcnJvciwgc2UgPSBjb25zb2xlLmdyb3VwLCBsZSA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIGZlID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHZhbHVlOiBjZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogZSxcbiAgICAgICAgICAgIGxvZzogZSxcbiAgICAgICAgICAgIHdhcm46IGUsXG4gICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgIGdyb3VwOiBlLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGUsXG4gICAgICAgICAgICBncm91cEVuZDogZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWWUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChJLS0sIEkgPT09IDApIHtcbiAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgbG9nOiBEKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBhZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiBEKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBpZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YXJuOiBEKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBvZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvcjogRCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogdWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXA6IEQoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHNlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBEKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBsZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cEVuZDogRCh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogZmVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgSSA8IDAgJiYgcChcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBKID0gTy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBHO1xuICAgIGZ1bmN0aW9uIE0oZSwgciwgdCkge1xuICAgICAge1xuICAgICAgICBpZiAoRyA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgICAgICAgIHZhciBuID0gdS5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgIEcgPSBuICYmIG5bMV0gfHwgXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXG5gICsgRyArIGU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB6ID0gITEsIEI7XG4gICAge1xuICAgICAgdmFyIE1lID0gdHlwZW9mIFdlYWtNYXAgPT0gXCJmdW5jdGlvblwiID8gV2Vha01hcCA6IE1hcDtcbiAgICAgIEIgPSBuZXcgTWUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGUoZSwgcikge1xuICAgICAgaWYgKCFlIHx8IHopXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IEIuZ2V0KGUpO1xuICAgICAgICBpZiAodCAhPT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgICAgdmFyIG47XG4gICAgICB6ID0gITA7XG4gICAgICB2YXIgdSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcztcbiAgICAgIHMgPSBKLmN1cnJlbnQsIEouY3VycmVudCA9IG51bGwsIFdlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIHZhciBvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChvLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChTKSB7XG4gICAgICAgICAgICAgIG4gPSBTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZSwgW10sIG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKFMpIHtcbiAgICAgICAgICAgICAgbiA9IFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLmNhbGwoby5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChTKSB7XG4gICAgICAgICAgICBuID0gUztcbiAgICAgICAgICB9XG4gICAgICAgICAgZSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChTKSB7XG4gICAgICAgIGlmIChTICYmIG4gJiYgdHlwZW9mIFMuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBTLnN0YWNrLnNwbGl0KGBcbmApLCBnID0gbi5zdGFjay5zcGxpdChgXG5gKSwgbCA9IGkubGVuZ3RoIC0gMSwgZiA9IGcubGVuZ3RoIC0gMTsgbCA+PSAxICYmIGYgPj0gMCAmJiBpW2xdICE9PSBnW2ZdOyApXG4gICAgICAgICAgICBmLS07XG4gICAgICAgICAgZm9yICg7IGwgPj0gMSAmJiBmID49IDA7IGwtLSwgZi0tKVxuICAgICAgICAgICAgaWYgKGlbbF0gIT09IGdbZl0pIHtcbiAgICAgICAgICAgICAgaWYgKGwgIT09IDEgfHwgZiAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKGwtLSwgZi0tLCBmIDwgMCB8fCBpW2xdICE9PSBnW2ZdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfID0gYFxuYCArIGlbbF0ucmVwbGFjZShcIiBhdCBuZXcgXCIsIFwiIGF0IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgJiYgXy5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChfID0gXy5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZS5kaXNwbGF5TmFtZSkpLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgQi5zZXQoZSwgXyksIF87XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGwgPj0gMSAmJiBmID49IDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgeiA9ICExLCBKLmN1cnJlbnQgPSBzLCBZZSgpLCBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHU7XG4gICAgICB9XG4gICAgICB2YXIgRiA9IGUgPyBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSA6IFwiXCIsIHdlID0gRiA/IE0oRikgOiBcIlwiO1xuICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiAmJiBCLnNldChlLCB3ZSksIHdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCZShlLCByLCB0KSB7XG4gICAgICByZXR1cm4gZGUoZSwgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWZShlKSB7XG4gICAgICB2YXIgciA9IGUucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKHIgJiYgci5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVihlLCByLCB0KSB7XG4gICAgICBpZiAoZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBkZShlLCBWZShlKSk7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIE0oZSk7XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSBiOlxuICAgICAgICAgIHJldHVybiBNKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgbTpcbiAgICAgICAgICByZXR1cm4gTShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIGQ6XG4gICAgICAgICAgICByZXR1cm4gQmUoZS5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgVDpcbiAgICAgICAgICAgIHJldHVybiBWKGUudHlwZSwgciwgdCk7XG4gICAgICAgICAgY2FzZSB3OiB7XG4gICAgICAgICAgICB2YXIgbiA9IGUsIHUgPSBuLl9wYXlsb2FkLCBzID0gbi5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBWKHModSksIHIsIHQpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIFUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCB2ZSA9IHt9LCBwZSA9IE8uUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBxKGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciByID0gZS5fb3duZXIsIHQgPSBWKGUudHlwZSwgZS5fc291cmNlLCByID8gci50eXBlIDogbnVsbCk7XG4gICAgICAgIHBlLnNldEV4dHJhU3RhY2tGcmFtZSh0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBwZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVlKGUsIHIsIHQsIG4sIHUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoVSk7XG4gICAgICAgIGZvciAodmFyIG8gaW4gZSlcbiAgICAgICAgICBpZiAocyhlLCBvKSkge1xuICAgICAgICAgICAgdmFyIGkgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGVbb10gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBFcnJvcigobiB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgdCArIFwiIHR5cGUgYFwiICsgbyArIFwiYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgXCIgKyB0eXBlb2YgZVtvXSArIFwiYC5UaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC5cIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZy5uYW1lID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCIsIGc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaSA9IGVbb10ociwgbywgbiwgdCwgbnVsbCwgXCJTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGwpIHtcbiAgICAgICAgICAgICAgaSA9IGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICYmICEoaSBpbnN0YW5jZW9mIEVycm9yKSAmJiAocSh1KSwgcChcIiVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiBZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciBjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kIHNoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS5cIiwgbiB8fCBcIlJlYWN0IGNsYXNzXCIsIHQsIG8sIHR5cGVvZiBpKSwgcShudWxsKSksIGkgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGkubWVzc2FnZSBpbiB2ZSkgJiYgKHZlW2kubWVzc2FnZV0gPSAhMCwgcSh1KSwgcChcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCB0LCBpLm1lc3NhZ2UpLCBxKG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBxZSA9IEFycmF5LmlzQXJyYXk7XG4gICAgZnVuY3Rpb24gSyhlKSB7XG4gICAgICByZXR1cm4gcWUoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEplKGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHIgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIHQgPSByICYmIGVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBlLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEdlKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB5ZShlKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB5ZShlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhlKGUpIHtcbiAgICAgIGlmIChHZShlKSlcbiAgICAgICAgcmV0dXJuIHAoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgSmUoZSkpLCB5ZShlKTtcbiAgICB9XG4gICAgdmFyIE4gPSBPLlJlYWN0Q3VycmVudE93bmVyLCB6ZSA9IHtcbiAgICAgIGtleTogITAsXG4gICAgICByZWY6ICEwLFxuICAgICAgX19zZWxmOiAhMCxcbiAgICAgIF9fc291cmNlOiAhMFxuICAgIH0sIG1lLCBnZSwgWDtcbiAgICBYID0ge307XG4gICAgZnVuY3Rpb24gS2UoZSkge1xuICAgICAgaWYgKFUuY2FsbChlLCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgXCJyZWZcIikuZ2V0O1xuICAgICAgICBpZiAociAmJiByLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLnJlZiAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBYZShlKSB7XG4gICAgICBpZiAoVS5jYWxsKGUsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChyICYmIHIuaXNSZWFjdFdhcm5pbmcpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGUua2V5ICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFplKGUsIHIpIHtcbiAgICAgIGlmICh0eXBlb2YgZS5yZWYgPT0gXCJzdHJpbmdcIiAmJiBOLmN1cnJlbnQgJiYgciAmJiBOLmN1cnJlbnQuc3RhdGVOb2RlICE9PSByKSB7XG4gICAgICAgIHZhciB0ID0gUChOLmN1cnJlbnQudHlwZSk7XG4gICAgICAgIFhbdF0gfHwgKHAoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBQKE4uY3VycmVudC50eXBlKSwgZS5yZWYpLCBYW3RdID0gITApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBRZShlLCByKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbWUgfHwgKG1lID0gITAsIHAoXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCByKSk7XG4gICAgICAgIH07XG4gICAgICAgIHQuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwia2V5XCIsIHtcbiAgICAgICAgICBnZXQ6IHQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gSGUoZSwgcikge1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGdlIHx8IChnZSA9ICEwLCBwKFwiJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgcikpO1xuICAgICAgICB9O1xuICAgICAgICB0LmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInJlZlwiLCB7XG4gICAgICAgICAgZ2V0OiB0LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBlciA9IGZ1bmN0aW9uKGUsIHIsIHQsIG4sIHUsIHMsIG8pIHtcbiAgICAgIHZhciBpID0ge1xuICAgICAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAgICAgJCR0eXBlb2Y6IHYsXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogZSxcbiAgICAgICAga2V5OiByLFxuICAgICAgICByZWY6IHQsXG4gICAgICAgIHByb3BzOiBvLFxuICAgICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICBfb3duZXI6IHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gaS5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGkuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAhMVxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9zZWxmXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IG5cbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSwgXCJfc291cmNlXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IHVcbiAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKGkucHJvcHMpLCBPYmplY3QuZnJlZXplKGkpKSwgaTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJyKGUsIHIsIHQsIG4sIHUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHMsIG8gPSB7fSwgaSA9IG51bGwsIGcgPSBudWxsO1xuICAgICAgICB0ICE9PSB2b2lkIDAgJiYgKGhlKHQpLCBpID0gXCJcIiArIHQpLCBYZShyKSAmJiAoaGUoci5rZXkpLCBpID0gXCJcIiArIHIua2V5KSwgS2UocikgJiYgKGcgPSByLnJlZiwgWmUociwgdSkpO1xuICAgICAgICBmb3IgKHMgaW4gcilcbiAgICAgICAgICBVLmNhbGwociwgcykgJiYgIXplLmhhc093blByb3BlcnR5KHMpICYmIChvW3NdID0gcltzXSk7XG4gICAgICAgIGlmIChlICYmIGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgdmFyIGwgPSBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBmb3IgKHMgaW4gbClcbiAgICAgICAgICAgIG9bc10gPT09IHZvaWQgMCAmJiAob1tzXSA9IGxbc10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIHx8IGcpIHtcbiAgICAgICAgICB2YXIgZiA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIHx8IFwiVW5rbm93blwiIDogZTtcbiAgICAgICAgICBpICYmIFFlKG8sIGYpLCBnICYmIEhlKG8sIGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcihlLCBpLCBnLCB1LCBuLCBOLmN1cnJlbnQsIG8pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgWiA9IE8uUmVhY3RDdXJyZW50T3duZXIsIEVlID0gTy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIEEoZSkge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdmFyIHIgPSBlLl9vd25lciwgdCA9IFYoZS50eXBlLCBlLl9zb3VyY2UsIHIgPyByLnR5cGUgOiBudWxsKTtcbiAgICAgICAgRWUuc2V0RXh0cmFTdGFja0ZyYW1lKHQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIEVlLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgdmFyIFE7XG4gICAgUSA9ICExO1xuICAgIGZ1bmN0aW9uIEgoZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBlLiQkdHlwZW9mID09PSB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKFouY3VycmVudCkge1xuICAgICAgICAgIHZhciBlID0gUChaLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBcXGBgICsgZSArIFwiYC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHIoZSkge1xuICAgICAge1xuICAgICAgICBpZiAoZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sIFwiXCIpLCB0ID0gZS5saW5lTnVtYmVyO1xuICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHlvdXIgY29kZSBhdCBgICsgciArIFwiOlwiICsgdCArIFwiLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgX2UgPSB7fTtcbiAgICBmdW5jdGlvbiBucihlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gYmUoKTtcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgdmFyIHQgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lO1xuICAgICAgICAgIHQgJiYgKHIgPSBgXG5cbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPGAgKyB0ICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmUoZSwgcikge1xuICAgICAge1xuICAgICAgICBpZiAoIWUuX3N0b3JlIHx8IGUuX3N0b3JlLnZhbGlkYXRlZCB8fCBlLmtleSAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZS5fc3RvcmUudmFsaWRhdGVkID0gITA7XG4gICAgICAgIHZhciB0ID0gbnIocik7XG4gICAgICAgIGlmIChfZVt0XSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIF9lW3RdID0gITA7XG4gICAgICAgIHZhciBuID0gXCJcIjtcbiAgICAgICAgZSAmJiBlLl9vd25lciAmJiBlLl9vd25lciAhPT0gWi5jdXJyZW50ICYmIChuID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBQKGUuX293bmVyLnR5cGUpICsgXCIuXCIpLCBBKGUpLCBwKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCB0LCBuKSwgQShudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gVGUoZSwgcikge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChLKGUpKVxuICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgdmFyIG4gPSBlW3RdO1xuICAgICAgICAgICAgSChuKSAmJiBSZShuLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEgoZSkpXG4gICAgICAgICAgZS5fc3RvcmUgJiYgKGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwKTtcbiAgICAgICAgZWxzZSBpZiAoZSkge1xuICAgICAgICAgIHZhciB1ID0gWShlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiICYmIHUgIT09IGUuZW50cmllcylcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSB1LmNhbGwoZSksIG87ICEobyA9IHMubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgICAgIEgoby52YWx1ZSkgJiYgUmUoby52YWx1ZSwgcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXIoZSkge1xuICAgICAge1xuICAgICAgICB2YXIgciA9IGUudHlwZTtcbiAgICAgICAgaWYgKHIgPT0gbnVsbCB8fCB0eXBlb2YgciA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGlmICh0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdCA9IHIucHJvcFR5cGVzO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgciA9PSBcIm9iamVjdFwiICYmIChyLiQkdHlwZW9mID09PSBkIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAgICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgICAgIHIuJCR0eXBlb2YgPT09IFQpKVxuICAgICAgICAgIHQgPSByLnByb3BUeXBlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICB2YXIgbiA9IFAocik7XG4gICAgICAgICAgVWUodCwgZS5wcm9wcywgXCJwcm9wXCIsIG4sIGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHIuUHJvcFR5cGVzICE9PSB2b2lkIDAgJiYgIVEpIHtcbiAgICAgICAgICBRID0gITA7XG4gICAgICAgICAgdmFyIHUgPSBQKHIpO1xuICAgICAgICAgIHAoXCJDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD9cIiwgdSB8fCBcIlVua25vd25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZW9mIHIuZ2V0RGVmYXVsdFByb3BzID09IFwiZnVuY3Rpb25cIiAmJiAhci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgcChcImdldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyBkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpcihlKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIHIgPSBPYmplY3Qua2V5cyhlLnByb3BzKSwgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgdmFyIG4gPSByW3RdO1xuICAgICAgICAgIGlmIChuICE9PSBcImNoaWxkcmVuXCIgJiYgbiAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgQShlKSwgcChcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIG4pLCBBKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUucmVmICE9PSBudWxsICYmIChBKGUpLCBwKFwiSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC5cIiksIEEobnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBDZShlLCByLCB0LCBuLCB1LCBzKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBvID0gTGUoZSk7XG4gICAgICAgIGlmICghbykge1xuICAgICAgICAgIHZhciBpID0gXCJcIjtcbiAgICAgICAgICAoZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPT09IDApICYmIChpICs9IFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIik7XG4gICAgICAgICAgdmFyIGcgPSB0cih1KTtcbiAgICAgICAgICBnID8gaSArPSBnIDogaSArPSBiZSgpO1xuICAgICAgICAgIHZhciBsO1xuICAgICAgICAgIGUgPT09IG51bGwgPyBsID0gXCJudWxsXCIgOiBLKGUpID8gbCA9IFwiYXJyYXlcIiA6IGUgIT09IHZvaWQgMCAmJiBlLiQkdHlwZW9mID09PSB2ID8gKGwgPSBcIjxcIiArIChQKGUudHlwZSkgfHwgXCJVbmtub3duXCIpICsgXCIgLz5cIiwgaSA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogbCA9IHR5cGVvZiBlLCBwKFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsIGwsIGkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmID0gcnIoZSwgciwgdCwgdSwgcyk7XG4gICAgICAgIGlmIChmID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgdmFyIF8gPSByLmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChfICE9PSB2b2lkIDApXG4gICAgICAgICAgICBpZiAobilcbiAgICAgICAgICAgICAgaWYgKEsoXykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBGID0gMDsgRiA8IF8ubGVuZ3RoOyBGKyspXG4gICAgICAgICAgICAgICAgICBUZShfW0ZdLCBlKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoXyk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHAoXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBUZShfLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSA9PT0gYyA/IGlyKGYpIDogYXIoZiksIGY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9yKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBDZShlLCByLCB0LCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVyKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBDZShlLCByLCB0LCAhMSk7XG4gICAgfVxuICAgIHZhciBzciA9IHVyLCBsciA9IG9yO1xuICAgICQuRnJhZ21lbnQgPSBjLCAkLmpzeCA9IHNyLCAkLmpzeHMgPSBscjtcbiAgfSgpKSwgJDtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGVlLmV4cG9ydHMgPSBkcigpIDogZWUuZXhwb3J0cyA9IHZyKCk7XG52YXIgcmUgPSBlZS5leHBvcnRzO1xuY29uc3QgcHIgPSB4ZShmdW5jdGlvbih7IG9wZW46IHYsIG9uU2hvdzogeSwgb25IaWRlOiBjLCBjaGlsZHJlbjogQywgLi4ueCB9LCBoKSB7XG4gIGNvbnN0IFthLCBkXSA9IGplKCksIHsgdGl0bGVCYXI6IGIsIHNhdmVCYXI6IG0sIG1vZGFsQ29udGVudDogVCB9ID0gZnIudG9BcnJheShDKS5yZWR1Y2UoXG4gICAgKEUsIGspID0+IHtcbiAgICAgIGNvbnN0IFcgPSB5cihrKSwgWSA9IFcgPT09IFwidWktdGl0bGUtYmFyXCIsIE8gPSBXID09PSBcInVpLXNhdmUtYmFyXCI7XG4gICAgICByZXR1cm4gIVkgJiYgIU8gJiYgRS5tb2RhbENvbnRlbnQucHVzaChrKSwge1xuICAgICAgICAuLi5FLFxuICAgICAgICB0aXRsZUJhcjogWSA/IGsgOiBFLnRpdGxlQmFyLFxuICAgICAgICBzYXZlQmFyOiBPID8gayA6IEUuc2F2ZUJhclxuICAgICAgfTtcbiAgICB9LFxuICAgIHsgbW9kYWxDb250ZW50OiBbXSB9XG4gICksIHcgPSBhICYmIGEuY29udGVudCA/IGNyLmNyZWF0ZVBvcnRhbChULCBhLmNvbnRlbnQpIDogbnVsbDtcbiAgcmV0dXJuIGooKCkgPT4ge1xuICAgIGEgJiYgKHYgPyBhLnNob3coKSA6IGEuaGlkZSgpKTtcbiAgfSwgW2EsIHZdKSwgaigoKSA9PiB7XG4gICAgaWYgKCEoIWEgfHwgIXkpKVxuICAgICAgcmV0dXJuIGEuYWRkRXZlbnRMaXN0ZW5lcihcInNob3dcIiwgeSksICgpID0+IHtcbiAgICAgICAgYS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2hvd1wiLCB5KTtcbiAgICAgIH07XG4gIH0sIFthLCB5XSksIGooKCkgPT4ge1xuICAgIGlmICghKCFhIHx8ICFjKSlcbiAgICAgIHJldHVybiBhLmFkZEV2ZW50TGlzdGVuZXIoXCJoaWRlXCIsIGMpLCAoKSA9PiB7XG4gICAgICAgIGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImhpZGVcIiwgYyk7XG4gICAgICB9O1xuICB9LCBbYSwgY10pLCBqKCgpID0+IHtcbiAgICBpZiAoYSlcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGEuaGlkZSgpO1xuICAgICAgfTtcbiAgfSwgW2FdKSwgLyogQF9fUFVSRV9fICovIHJlLmpzeHMoXG4gICAgXCJ1aS1tb2RhbFwiLFxuICAgIHtcbiAgICAgIC4uLngsXG4gICAgICByZWY6IChFKSA9PiB7XG4gICAgICAgIGQoRSksIGggJiYgKHR5cGVvZiBoID09IFwiZnVuY3Rpb25cIiA/IGgoRSkgOiBoLmN1cnJlbnQgPSBFKTtcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICBiLFxuICAgICAgICBtLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gcmUuanN4KFwiZGl2XCIsIHsgY2hpbGRyZW46IHcgfSlcbiAgICAgIF1cbiAgICB9XG4gICk7XG59KTtcbnByLmRpc3BsYXlOYW1lID0gXCJ1aS1tb2RhbFwiO1xuZnVuY3Rpb24geXIoUikge1xuICBpZiAoIVIpXG4gICAgcmV0dXJuO1xuICBjb25zdCB2ID0gdHlwZW9mIFIgPT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiBSID8gUi50eXBlIDogdm9pZCAwLCB5ID0gdHlwZW9mIHYgPT0gXCJzdHJpbmdcIiA/IHYgOiB2b2lkIDAsIGMgPSB0eXBlb2YgdiA9PSBcIm9iamVjdFwiID8gdi5kaXNwbGF5TmFtZSA6IHZvaWQgMDtcbiAgcmV0dXJuIHkgfHwgKHR5cGVvZiBjID09IFwic3RyaW5nXCIgPyBjIDogdm9pZCAwKTtcbn1cbmNvbnN0IGJyID0gXCJ1aS1uYXYtbWVudVwiLCBfciA9IFwidWktdGl0bGUtYmFyXCIsIGhyID0geGUoZnVuY3Rpb24oeyBvcGVuOiB2LCBvblNob3c6IHksIG9uSGlkZTogYywgY2hpbGRyZW46IEMsIC4uLnggfSwgaCkge1xuICBjb25zdCBbYSwgZF0gPSBqZSgpO1xuICByZXR1cm4gaigoKSA9PiB7XG4gICAgYSAmJiAodiA/IGEuc2hvdygpIDogYS5oaWRlKCkpO1xuICB9LCBbYSwgdl0pLCBqKCgpID0+IHtcbiAgICBpZiAoISghYSB8fCAheSkpXG4gICAgICByZXR1cm4gYS5hZGRFdmVudExpc3RlbmVyKFwic2hvd1wiLCB5KSwgKCkgPT4ge1xuICAgICAgICBhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzaG93XCIsIHkpO1xuICAgICAgfTtcbiAgfSwgW2EsIHldKSwgaigoKSA9PiB7XG4gICAgaWYgKCEoIWEgfHwgIWMpKVxuICAgICAgcmV0dXJuIGEuYWRkRXZlbnRMaXN0ZW5lcihcImhpZGVcIiwgYyksICgpID0+IHtcbiAgICAgICAgYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaGlkZVwiLCBjKTtcbiAgICAgIH07XG4gIH0sIFthLCBjXSksIGooKCkgPT4ge1xuICAgIGlmIChhKVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgYS5oaWRlKCk7XG4gICAgICB9O1xuICB9LCBbYV0pLCAvKiBAX19QVVJFX18gKi8gcmUuanN4KFxuICAgIFwidWktc2F2ZS1iYXJcIixcbiAgICB7XG4gICAgICAuLi54LFxuICAgICAgcmVmOiAoYikgPT4ge1xuICAgICAgICBkKGIpLCBoICYmICh0eXBlb2YgaCA9PSBcImZ1bmN0aW9uXCIgPyBoKGIpIDogaC5jdXJyZW50ID0gYik7XG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IENcbiAgICB9XG4gICk7XG59KTtcbmhyLmRpc3BsYXlOYW1lID0gXCJ1aS1zYXZlLWJhclwiO1xuY29uc3QgbXIgPSBuZXcgUHJveHkoXG4gIHt9LFxuICB7XG4gICAgZ2V0KFIsIHYpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgc2hvcGlmeS4ke1N0cmluZyhcbiAgICAgICAgICB2XG4gICAgICAgICl9IGNhbid0IGJlIHVzZWQgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuIFlvdSBsaWtlbHkgbmVlZCB0byBtb3ZlIHRoaXMgY29kZSBpbnRvIGFuIEVmZmVjdC5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuKTtcbmZ1bmN0aW9uIFJyKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA+IFwidVwiKVxuICAgIHJldHVybiBtcjtcbiAgaWYgKCF3aW5kb3cuc2hvcGlmeSlcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwiVGhlIHNob3BpZnkgZ2xvYmFsIGlzIG5vdCBkZWZpbmVkLiBUaGlzIGxpa2VseSBtZWFucyB0aGUgQXBwIEJyaWRnZSBzY3JpcHQgdGFnIHdhcyBub3QgYWRkZWQgY29ycmVjdGx5IHRvIHRoaXMgcGFnZVwiXG4gICAgKTtcbiAgcmV0dXJuIHdpbmRvdy5zaG9waWZ5O1xufVxuZXhwb3J0IHtcbiAgcHIgYXMgTW9kYWwsXG4gIGJyIGFzIE5hdk1lbnUsXG4gIGhyIGFzIFNhdmVCYXIsXG4gIF9yIGFzIFRpdGxlQmFyLFxuICBSciBhcyB1c2VBcHBCcmlkZ2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@shopify+app-bridge-react@4.1.6_react-dom@18.3.1_react@18.3.1/node_modules/@shopify/app-bridge-react/dist/index.js\n");

/***/ })

};
;